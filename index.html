<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Outbound AMZL Tool</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="." />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --system-font: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            --mono-font: 'SF Mono', Consolas, 'Courier New', Courier, monospace;
            --primary-bg: #ffffff;
            --container-bg: #ffffff;
            --text-color: #1d1d1f; /* Default black text */
            --secondary-text-color: #6e6e73;
            --placeholder-text-color: #aaaaaf;
            --accent-blue: #007aff; /* Kept for focus rings, checkboxes, etc. */
            --accent-blue-rgb: 0, 122, 255;

            /* Button Colors - Now Black with White Text */
            --button-bg: #1d1d1f; /* Black background for buttons */
            --button-text: #ffffff; /* White text for buttons */
            --button-border-color: #1d1d1f; /* Match background for solid look */
            --button-hover-bg: #38383a; /* Slightly lighter black for hover */
            --button-hover-border-color: #38383a;
            --button-active-bg: #4f4f52; /* Even lighter for active */
            --button-active-border-color: #4f4f52;
            --button-disabled-bg: #e0e0e0; /* Light grey for disabled */
            --button-disabled-text: #9e9e9e; /* Darker grey text for disabled */
            --button-disabled-border: #e0e0e0;

            --border-color: #d2d2d7; /* General border color (light grey) */
            --focus-ring-color: rgba(var(--accent-blue-rgb), 0.25);
            /* Shadows removed as per request */
            --base-border-radius: 10px;
            --button-border-radius: 6px;
            --input-border-radius: 6px;
            --top-bar-height: 50px;
        }
        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }
        body {
            font-family: var(--system-font); background-color: var(--primary-bg);
            color: var(--text-color); margin: 0; padding: 0; display: flex;
            flex-direction: column; min-height: 100vh;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            font-size: 14px;
        }

        .top-bar {
            background-color: var(--primary-bg);
            padding: 0 24px;
            height: var(--top-bar-height);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-shrink: 0;
            /* border-bottom: 1px solid var(--border-color); Removed */
        }

        .top-bar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .hamburger-icon {
            font-size: 1.2em;
            color: var(--text-color);
            cursor: pointer;
        }

        .top-bar-title {
            font-size: 1.3em; /* Increased title size */
            font-weight: 600;
            color: var(--text-color);
            margin: 0;
        }

        .version-dropdown {
            position: relative;
            display: inline-block;
        }
        /* Specific style for Version 1 button */
        .version-button {
            background-color: var(--primary-bg); /* White background */
            color: var(--text-color); /* Black text */
            padding: 6px 12px;
            border: 1px solid var(--border-color); /* Grey border */
            border-radius: var(--button-border-radius);
            cursor: pointer;
            font-family: var(--system-font);
            font-weight: 500;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            transition: background-color 0.15s ease, border-color 0.15s ease;
        }
        .version-button:hover { background-color: #f0f0f0; } /* Light grey hover for white button */
        .version-button:active { background-color: #e0e0e0; transform: scale(0.97); }
        .version-button i { margin-left: 6px; font-size: 0.8em; }

        .version-dropdown-content {
            display: none; position: absolute; background-color: var(--primary-bg);
            min-width: 120px; box-shadow: 0 3px 8px rgba(0, 0, 0, 0.08); /* Kept a light shadow for dropdown */
            z-index: 1001; border-radius: var(--button-border-radius);
            border: 1px solid var(--border-color); right: 0; margin-top: 4px;
        }
        .version-dropdown-content a { color: var(--text-color); padding: 8px 12px; text-decoration: none; display: block; font-size: 13px; white-space: nowrap; }
        .version-dropdown-content a:hover { background-color: #f0f0f0; }
        .version-dropdown:hover .version-dropdown-content,
        .version-dropdown .version-button:focus + .version-dropdown-content,
        .version-dropdown .version-dropdown-content:hover {
            display: block;
        }

        .main-wrapper {
            display: flex; flex-direction: column; flex-grow: 1; padding: 16px; gap: 16px;
            width: 100%; max-width: 1600px; margin: 0 auto; overflow: hidden;
        }

        .left-column-wrapper {
            display: flex; flex-direction: column; gap: 16px;
        }

        .tool-card-title {
            display: none; /* Hidden by default, shown on wide screens */
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-color);
            margin: -5px 0 15px 0; /* Adjust to align with card padding */
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        @media (min-width: 992px) {
            .main-wrapper {
                flex-direction: row; padding: 24px; gap: 24px; align-items: stretch;
                /* ... other main-wrapper styles ... */
            }
            .tool-card-title {
                display: block; /* Show titles on wide screens */
            }
            .left-column-wrapper {
                /* OLD: width: 35%; */
                width: calc(35% - (24px * 0.35)); /* NEW: Adjust for gap. (24px * 0.35 = 8.4px) */
                flex-shrink: 0;
                gap: 24px; /* This gap is for items *inside* left-column-wrapper, not between left and right columns */
                max-height: calc(100vh - var(--top-bar-height) - (2 * 24px));
                overflow-y: auto; padding-bottom: 1px;
            }
            .note-taker-tool {
                /* OLD: width: 65%; */
                width: calc(65% - (24px * 0.65)); /* NEW: Adjust for gap. (24px * 0.65 = 15.6px) */
                flex-shrink: 0;
                display: flex; flex-direction: column;
                max-height: calc(100vh - var(--top-bar-height) - (2 * 24px));
            }
             #noteArea { flex-grow: 1; min-height: 200px; }
             .note-taker-tool .controls-and-stats { flex-shrink: 0; margin-top: 16px; }
             .merchant-actions-tool #merchantList { height: 220px; }
        }
        
        @media (max-width: 991px) {
            .top-bar { display: none; }
            .main-wrapper { overflow-y: auto; overflow-x: hidden; max-height: 100vh; }
             .left-column-wrapper, .note-taker-tool { max-height: none; overflow-y: visible; }
             #noteArea { min-height: 300px; }
             .merchant-actions-tool #merchantList { height: 200px; }
        }

        .tool-container {
             background-color: var(--container-bg); border-radius: var(--base-border-radius);
             /* box-shadow: 0 1px 2px var(--shadow-color-light), 0 3px 8px var(--shadow-color-medium); Removed shadow */
             box-shadow: none;
             padding: 20px;
             display: flex; flex-direction: column; position: relative;
             border: 1px solid var(--border-color);
         }

        textarea, input[type="text"], input[type="number"] {
            width: 100%; margin-bottom: 12px; padding: 10px 12px;
            border: 1px solid var(--border-color); border-radius: var(--input-border-radius);
            background-color: var(--container-bg);
            color: var(--text-color);
            line-height: 1.5; font-family: var(--system-font); font-size: 14px;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: none;
        }
        textarea { font-family: var(--mono-font); resize: vertical; min-height: 100px; }
        textarea::placeholder, input::placeholder { color: var(--placeholder-text-color); }
        textarea:focus, input[type="text"]:focus, input[type="number"]:focus {
            border-color: var(--accent-blue); outline: none;
            box-shadow: 0 0 0 3px var(--focus-ring-color);
        }
        input[type="number"] { width: auto; margin-bottom: 0; }

       #shipmentInput { margin-bottom: 0; min-height: 150px; }

        button {
            background-color: var(--button-bg); color: var(--button-text);
            padding: 7px 14px;
            border: 1px solid var(--button-border-color);
            border-radius: var(--button-border-radius); cursor: pointer; margin: 0;
            transition: background-color 0.15s ease, border-color 0.15s ease, transform 0.1s ease;
            font-family: var(--system-font);
            font-weight: 500; font-size: 13px;
            flex-shrink: 0; text-align: center; display: inline-flex;
            align-items: center; justify-content: center; position: relative; overflow: hidden;
            box-shadow: none;
        }
        button:hover {
            background-color: var(--button-hover-bg);
            border-color: var(--button-hover-border-color);
        }
        button:active {
            background-color: var(--button-active-bg);
            border-color: var(--button-active-border-color);
            transform: scale(0.97);
        }
        button:disabled {
            background-color: var(--button-disabled-bg);
            color: var(--button-disabled-text);
            border-color: var(--button-disabled-border);
            cursor: not-allowed;
        }
        button:disabled:hover {
            background-color: var(--button-disabled-bg);
            border-color: var(--button-disabled-border);
        }
        button:disabled:active { transform: none; }


        .note-taker-tool .controls-and-stats { display: flex; flex-direction: column; gap: 12px; flex-shrink: 0; margin-top: auto; }
        .note-taker-tool .top-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; }
        .note-taker-tool .button-group { display: flex; gap: 8px; flex-wrap: wrap; }

        /* Counter Pill styled like a white button */
        .note-taker-tool .counter-pill {
            display: inline-flex; align-items: center; gap: 12px;
            background-color: var(--primary-bg); /* White background */
            padding: 7px 14px; /* Match button padding */
            border-radius: var(--button-border-radius); /* Match button radius */
            border: 1px solid var(--border-color); /* Grey border */
            font-size: 13px; /* Match button font size */
            font-weight: 500; /* Match button font weight */
        }
        .note-taker-tool .counter-pill p {
            margin: 0;
            color: var(--text-color); /* Black text */
        }
        .note-taker-tool .counter-pill span {
            font-weight: 600; /* Keep span slightly bolder */
            color: var(--text-color); /* Black text */
            margin-left: 2px;
        }

        .merchant-actions-tool .bulk-actions {
            margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap; flex-shrink: 0;
        }
        .merchant-actions-tool #merchantList {
            min-height: 150px; max-height: 60vh; overflow-y: auto; resize: vertical;
            margin: 0; padding: 8px; border: 1px solid var(--border-color);
            border-radius: var(--input-border-radius); display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 8px; align-content: start;
        }
        .merchant-actions-tool .merchant-stats {
            margin: 0; padding: 7px 10px; background-color: transparent; border: none;
            border-radius: 5px; display: flex; align-items: center; justify-content: flex-start;
            font-size: 13px; transition: background-color 0.15s ease; cursor: pointer;
            border: 1px solid var(--border-color);
        }
        .merchant-actions-tool .merchant-stats:hover { background-color: #f0f0f5; }
        .merchant-actions-tool .merchant-stats:has(.merchant-checkbox:checked) { background-color: #e8f3ff; }
        .merchant-actions-tool .merchant-stats > div { display: flex; align-items: center; justify-content: flex-start; width: 100%; gap: 8px; }
        .merchant-actions-tool .merchant-checkbox { appearance: none; -webkit-appearance: none; -moz-appearance: none; width: 16px; height: 16px; border: 1px solid #c7c7cc; border-radius: 4px; outline: none; cursor: pointer; position: relative; transition: background-color 0.15s ease, border-color 0.15s ease; flex-shrink: 0; background-color: var(--container-bg); margin: 0; }
        .merchant-actions-tool .merchant-checkbox:checked { background-color: var(--accent-blue); border-color: var(--accent-blue); }
        .merchant-actions-tool .merchant-checkbox:checked::after { content: ''; position: absolute; top: 1px; left: 4px; width: 4px; height: 8px; border: solid white; border-width: 0 2px 2px 0; transform: rotate(45deg); }

        .merchant-name-display { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; cursor: text; padding: 2px 4px; border: 1px solid transparent; border-radius: 3px; display: inline-block; flex-grow: 1; }
        .merchant-name-display:focus { border: 1px solid var(--accent-blue); background-color: var(--primary-bg); box-shadow: 0 0 0 3px var(--focus-ring-color); outline: none; white-space: normal; overflow: visible; }
        .merchant-name-editable-container { display: flex; align-items: baseline; overflow: hidden; flex-grow: 1; min-width: 0; }
        .merchant-count-text { flex-shrink: 0; margin-left: 4px; }

        * { scrollbar-width: thin; scrollbar-color: #c0c0c0 transparent; }
        *::-webkit-scrollbar { width: 9px; height: 9px; }
        *::-webkit-scrollbar-track { background: transparent; }
        *::-webkit-scrollbar-thumb { background-color: #cccccc; border-radius: 5px; border: 2px solid transparent; background-clip: content-box; }
        *::-webkit-scrollbar-thumb:hover { background-color: #b3b3b3; }

        .parser-controls { display: flex; align-items: center; gap: 16px; margin-top: 12px; margin-bottom: 0; padding-bottom: 4px; flex-wrap: wrap; }
        .toggle-label { font-size: 13px; color: var(--text-color); cursor: pointer; user-select: none; margin-right: 4px; }
        .toggle-switch { position: relative; display: inline-block; width: 40px; height: 22px; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #c7c7cc; transition: .3s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 2px; bottom: 2px; background-color: white; transition: .3s; box-shadow: 0 1px 3px rgba(0,0,0,0.15); }
        input:checked + .slider { background-color: var(--accent-blue); }
        input:focus + .slider { box-shadow: 0 0 0 2px var(--focus-ring-color); }
        input:checked + .slider:before { transform: translateX(18px); }
        .slider.round { border-radius: 22px; }
        .slider.round:before { border-radius: 50%; }
        /* .parser-group-label removed from HTML */
        #parserGroupSize { /* Renamed from .parser-group-input for specificity */
            width: 70px; /* Adjusted width */
            padding: 6px 8px; font-size: 13px; margin-bottom: 0; text-align: center;
            border: 1px solid var(--border-color); border-radius: var(--input-border-radius);
            background-color: var(--container-bg); transition: background-color 0.3s ease, opacity 0.3s ease;
        }
        #parserGroupSize:disabled { background-color: #f8f8f8; color: #bbb; cursor: not-allowed; opacity: 0.7; border-color: #e8e8ed; }

        .duplicate-indicator { display: inline-block; width: 8px; height: 8px; background-color: #ff9f0a; border-radius: 50%; margin-right: 6px; vertical-align: middle; flex-shrink: 0; box-shadow: none; }
        #upsUspsOutputArea { width: 100%; min-height: 80px; resize: vertical; border-radius: var(--input-border-radius); }
        #btnProcessUpsUsps { margin-top: 8px; } /* This button will also be black/white */
        #upsUspsOutputContainer { margin-top: 12px; padding-bottom: 4px; }

        #splitModal { backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); background-color: rgba(60,60,67,0.4); }
        #splitModalContent { background-color: #f9f9f9; margin: auto; padding: 20px; border: none; border-radius: 14px; width: 90%; max-width: 480px; box-shadow: 0 6px 20px rgba(0,0,0,0.12); display: flex; flex-direction: column; gap: 12px; }
        #splitModalContent h2 { margin-top: 0; margin-bottom: 8px; font-size: 1.15em; font-weight: 600; color: var(--text-color); border-bottom: 1px solid #e5e5ea; padding-bottom: 10px; text-align: center; }
        #splitModalContent label { font-size: 0.85rem; font-weight: 500; color: var(--secondary-text-color); margin-bottom: 4px; display: block; }
        #splitModalContent #splitOrdersPerTemplate, #splitModalContent #splitNumberInput { margin-bottom: 0; border-radius: var(--input-border-radius); }
        /* Buttons inside modal will also be black/white due to general button styling */
        #splitModalContent #splitOrdersPerTemplate { width: 60px; } /* Retain specific width for this input */
        #splitModalContent #splitNumberInput { width: 75px; flex-grow: 1; } /* Retain specific width for this input */
        #splitMerchantInfo { font-size: 0.9em; color: var(--secondary-text-color); background-color: #f0f0f5; padding: 8px 12px; border-radius: var(--input-border-radius); border: 1px solid var(--border-color); }
        #splitModalContent hr { border: none; border-top: 1px solid #e5e5ea; margin: 6px 0; }
        #splitModalContent .modal-actions { display: flex; gap: 10px; margin-top: 10px; justify-content: flex-end; }
    </style>
</head>
<body>

    <div class="top-bar">
        <div class="top-bar-left">
            <i class="fas fa-bars hamburger-icon"></i>
            <h1 class="top-bar-title">AMZL,UPS/USPS Outbound Tool</h1>
        </div>
        <div class="version-dropdown">
            <button id="versionButton" class="version-button" aria-haspopup="true" aria-expanded="false">Version 1 <i class="fas fa-chevron-down"></i></button>
            <div id="versionDropdownContent" class="version-dropdown-content" role="menu">
                <a href="#" role="menuitem">Version 1</a>
            </div>
        </div>
    </div>

    <div class="main-wrapper">
        <div class="left-column-wrapper">
            <div class="tool-container parser-tool">
                <h3 class="tool-card-title">Parser</h3>
                <textarea id="shipmentInput" placeholder="Paste Amazon removal shipment data here..."></textarea>
                <div class="parser-controls">
                    <div style="display: flex; align-items: center; gap: 8px;" id="groupOrdersControl">
                        <label class="toggle-switch">
                            <input type="checkbox" id="groupToggle"> <span class="slider round"></span>
                        </label>
                        <label for="groupToggle" class="toggle-label">Group Orders (AMZL)</label>
                        <input type="number" id="parserGroupSize" min="1" value="2" disabled>
                        <!-- Removed label for parserGroupSize -->
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <label class="toggle-switch">
                            <input type="checkbox" id="upsUspsToggle"> <span class="slider round"></span>
                        </label>
                        <label for="upsUspsToggle" class="toggle-label">Extract UPS/USPS</label>
                    </div>
                </div>
                <div id="upsUspsOutputContainer" style="display: none;">
                    <textarea id="upsUspsOutputArea" placeholder="Extracted UPS/USPS Tracking Numbers..."></textarea>
                    <button id="btnProcessUpsUsps">Process & Add to Notes</button>
                </div>
            </div>

            <div class="tool-container merchant-actions-tool">
                <h3 class="tool-card-title">Merchants</h3>
                <div class="bulk-actions">
                    <button id="btnDownloadSelected">Download Selected</button>
                    <button id="btnClearSelected">Clear Selected</button>
                    <button id="btnSelectAll">Select All</button>
                    <button id="btnSplitSelected" disabled>Split Selected</button>
                    <button id="btnDownloadAll">Download All Notes</button>
                </div>
                <div id="merchantList">
                    <!-- Merchant items will be dynamically added here by JS -->
                </div>
            </div>
        </div>

        <div class="tool-container note-taker-tool">
            <h3 class="tool-card-title">Notes</h3>
            <textarea id="noteArea" placeholder="Notes area..."></textarea>
            <div class="controls-and-stats">
                <div class="top-controls">
                    <div class="button-group">
                        <button id="btnAddSeparator">Add Separator</button>
                        <button id="btnAddSpacing">Add Spacing</button>
                        <button id="btnUndo" disabled>Undo</button> <!-- Placeholder -->
                        <button id="btnRedo" disabled>Redo</button> <!-- Placeholder -->
                    </div>
                    <div class="counter-pill">
                        <p class="merchant-count">Merchants: <span id="merchantCount">0</span></p>
                        <p class="total-templates">Cases: <span id="totalTemplates">0</span></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="splitModal" style="display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; justify-content: center; align-items: center; font-family: var(--system-font);">
        <div id="splitModalContent">
             <h2>Split Selected Merchant(s)</h2>
            <div id="splitMerchantInfo">
            </div>
            <div>
                <label for="splitOrdersPerTemplate">Removal Orders per Template:</label>
                <input type="number" id="splitOrdersPerTemplate" min="1" value="2">
            </div>
            <div style="font-size: 0.9em; color: var(--secondary-text-color);">
                Calculated Total Templates: <span id="splitCalculatedTemplates" style="font-weight: 600; color: var(--text-color);">0</span>
            </div>
            <hr>
            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                <label for="splitNumberInput" style="flex-shrink: 0;">Templates per Split File:</label>
                <input type="number" id="splitNumberInput" min="1" placeholder="e.g., 100">
            </div>
            <div class="modal-actions">
                <button id="btnCancelSplit">Cancel</button>
                <button id="btnGenerateSplits">Generate & Download Splits</button>
            </div>
        </div>
    </div>

<script>
    const amzlTemplate = `We've reviewed our removal orders and discovered some shipments whose delivery status is unclear. Could you please check on your end? We're unable to verify the tracking status. If they were lost in transit, could you kindly issue a reimbursement`;
    const upsUspsTemplate = `The Removal Order Status indicates "Completed," yet we never received this order. We kindly request a reimbursement for this discrepancy.`;
    const noteSeparator = '\n\n' + '-'.repeat(41) + '\n';
    const noteSeparatorRegex = /\n\n-{41}\n/g;
    const localStorageKey = 'savedNotesContent_amzlTool';
    const upsUspsOutputKey = 'stagedUpsUspsTNs_amzlTool';
    const upsUspsContextKey = 'stagedUpsUspsContext_amzlTool';

    let tempUpsUspsData = {};

    function saveNotesToLocalStorage() {
        const noteArea = document.getElementById('noteArea');
        if (noteArea) {
            localStorage.setItem(localStorageKey, noteArea.value);
        }
    }

    function saveUpsUspsOutputToLocalStorage() {
        const upsUspsOutputArea = document.getElementById('upsUspsOutputArea');
        if (upsUspsOutputArea) {
            localStorage.setItem(upsUspsOutputKey, upsUspsOutputArea.value);
        }
    }

    function saveUpsUspsContextToLocalStorage() {
        try {
            localStorage.setItem(upsUspsContextKey, JSON.stringify(tempUpsUspsData));
        } catch (error) {
            console.error("Error saving UPS/USPS context to localStorage:", error);
        }
    }

    function getFormattedDate() {
        const date = new Date();
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const day = date.getDate().toString().padStart(2, '0');
        return `${month}-${day}`;
    }

    function countTemplatesInText(text, templateString) {
        if (!text || !templateString) return 0;
        const escapedTemplate = templateString.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return (text.match(new RegExp(escapedTemplate, 'g')) || []).length;
    }

    function downloadText(text, filename) {
        try {
            const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        } catch (error) {
            console.error("Error during download:", error);
            alert("An error occurred while trying to download the file.");
        }
    }

    function sanitizeFilename(name) {
        return name.replace(/[\s\\/:"*?<>|]+/g, '_').substring(0, 50);
    }

    function parseShipmentData() {
        const input = document.getElementById('shipmentInput');
        const noteArea = document.getElementById('noteArea');
        const groupToggle = document.getElementById('groupToggle');
        const groupSizeInput = document.getElementById('parserGroupSize');
        const upsUspsToggle = document.getElementById('upsUspsToggle');
        const upsUspsOutputArea = document.getElementById('upsUspsOutputArea');
        const inputValue = input.value;
        const currentNoteValue = noteArea.value;

        if (!inputValue.trim()) { return; }

        const isUpsUspsMode = upsUspsToggle ? upsUspsToggle.checked : false;

        const trackingNumberSourceRegex = isUpsUspsMode
            ? /\b([A-Z0-9]+)\s*\((UPS|USPS)\)/gi
            : /\b([A-Z0-9]+(?:-|\s)*\(AMZ[NL]\))/g;

        const existingTrackingNumberRegexGlobal = /\b([A-Z0-9]+(?:-|\s)*\((?:AMZ[NL]|UPS|USPS)\))/gi;
        const existingTrackingNumbers = new Set();
        let matchCheck;
        while ((matchCheck = existingTrackingNumberRegexGlobal.exec(currentNoteValue)) !== null) {
            const coreTN = matchCheck[1].replace(/\s*\((?:AMZ[NL]|UPS|USPS)\)$/i, '').replace(/\s|-/g, '');
            if (coreTN) existingTrackingNumbers.add(coreTN);
        }
        if (upsUspsOutputArea && upsUspsOutputArea.value) {
            upsUspsOutputArea.value.split('\n').forEach(tn => {
                const trimmedTn = tn.trim();
                if (trimmedTn) existingTrackingNumbers.add(trimmedTn.replace(/\s|-/g, ''));
            });
        }
        const seenTrackingNumbersInCurrentInput = new Set();


        let groupSize = 1;
        const isGroupingActive = !isUpsUspsMode && groupToggle ? groupToggle.checked : false;
        if (isGroupingActive && groupSizeInput) {
            const parsedValue = parseInt(groupSizeInput.value, 10);
            groupSize = (!isNaN(parsedValue) && parsedValue >= 1) ? parsedValue : 2;
        }

        let removalOrderId = '';
        const removalOrderMatch = inputValue.match(/Removal order ID:\s*([^\n]+)/);
        if (removalOrderMatch) { removalOrderId = removalOrderMatch[1].trim(); }

        const shipmentSections = inputValue.split(/(?=Shipment ID:)/g).filter(section => section.trim() !== '');
        const parsedDataBlocksForAmzl = [];
        const extractedUpsUspsNumbers = [];
        let validShipmentsFound = 0;
        let skippedDuplicateCount = 0;

        shipmentSections.forEach(section => {
            const trackingMatches = Array.from(section.matchAll(trackingNumberSourceRegex));
            if (!trackingMatches || trackingMatches.length === 0) {
                return;
            }

            const sectionCoreTNs = new Set();
            const sectionFullTNs = [];
            trackingMatches.forEach(match => {
                let extractedPart = match[1];
                let fullFormattedTN = '';
                const coreTN = extractedPart.replace(/\s*\((?:AMZ[NL]|UPS|USPS)\)$/i, '').replace(/\s|-/g, '');

                if (!coreTN) return;

                sectionCoreTNs.add(coreTN);

                if (isUpsUspsMode) {
                    fullFormattedTN = `${match[1].trim()}(${match[2]})`;
                } else {
                    fullFormattedTN = extractedPart.replace(/\s*\((AMZ[NL])\)$/, '($1)');
                }
                sectionFullTNs.push(fullFormattedTN);
            });

            let hasDuplicate = false;
            const coreTNsToCheck = Array.from(sectionCoreTNs);

            for (const coreTn of coreTNsToCheck) {
                if (existingTrackingNumbers.has(coreTn) || seenTrackingNumbersInCurrentInput.has(coreTn)) {
                    hasDuplicate = true;
                    break;
                }
            }

            if (hasDuplicate) {
                skippedDuplicateCount++;
                coreTNsToCheck.forEach(tn => seenTrackingNumbersInCurrentInput.add(tn));
                return;
            }

             coreTNsToCheck.forEach(tn => seenTrackingNumbersInCurrentInput.add(tn));

            const shipmentIdMatch = section.match(/^Shipment ID:\s*([^\n]+)/m);
            const shipmentId = shipmentIdMatch ? shipmentIdMatch[1].trim() : 'N/A';

            const productLines = section.split('\n').map(line => line.trim());
            const parsedProducts = []; let currentProduct = null;
            for (let i = 0; i < productLines.length; i++) { const line = productLines[i]; if (line.startsWith('Merchant SKU:')) { if (currentProduct && currentProduct.merchantSku && currentProduct.qty !== undefined) { parsedProducts.push(currentProduct); } currentProduct = { merchantSku: line.substring('Merchant SKU:'.length).trim(), qty: undefined }; } else if (currentProduct) { if (line.startsWith('FNSKU:')) { currentProduct.fnsku = line.substring('FNSKU:'.length).trim(); } else if (/^\d{1,4}$/.test(line) && productLines[i - 1]?.match(/^(EAN|UPC|ISBN_10|Condition|Shipped Quantity|Cancelled Quantity):/i)) { currentProduct.qty = parseInt(line, 10); parsedProducts.push(currentProduct); currentProduct = null; } } } if (currentProduct && currentProduct.merchantSku && currentProduct.qty !== undefined && !parsedProducts.includes(currentProduct)) { parsedProducts.push(currentProduct); }


            if (parsedProducts.length === 0) { return; }

            const outputParts = [
                `Removal order ID:${removalOrderId}`,
                `Shipment ID:${shipmentId}`,
                `Tracking Number(s):${Array.from(new Set(sectionFullTNs)).join(', ')}`
            ];
            const productOutputs = parsedProducts.map(p => [`Merchant SKU:${p.merchantSku || 'N/A'}`, `FNSKU:${p.fnsku || 'N/A'}`, `Qty:${p.qty}`].join('\n') );
            const completeDataBlock = outputParts.join('\n') + '\n' + productOutputs.join('\n\n');

            if (isUpsUspsMode) {
                 coreTNsToCheck.forEach(coreTN => {
                     if (!tempUpsUspsData[coreTN]) {
                           tempUpsUspsData[coreTN] = completeDataBlock;
                     }
                    extractedUpsUspsNumbers.push(coreTN);
                 });
            } else {
                parsedDataBlocksForAmzl.push(completeDataBlock);
            }
            validShipmentsFound++;
        });

        if (isUpsUspsMode) {
            if (extractedUpsUspsNumbers.length > 0) {
                const uniqueNumbersToAdd = Array.from(new Set(extractedUpsUspsNumbers));
                upsUspsOutputArea.value += (upsUspsOutputArea.value ? '\n' : '') + uniqueNumbersToAdd.join('\n');
                upsUspsOutputArea.scrollTop = upsUspsOutputArea.scrollHeight;

                saveUpsUspsOutputToLocalStorage();
                saveUpsUspsContextToLocalStorage();

                input.value = '';
                let processedMessage = `Extracted ${uniqueNumbersToAdd.length} unique UPS/USPS number(s) for review. `;
                 if (skippedDuplicateCount > 0) { processedMessage += `Skipped ${skippedDuplicateCount} duplicate(s). `; }
                processedMessage += `Click 'Process' to add to notes.`;
                 input.placeholder = processedMessage;
            } else {
                input.value = '';
                 let message = "No new valid UPS/USPS shipments found. ";
                 if (skippedDuplicateCount > 0) { message += `Skipped ${skippedDuplicateCount} duplicate(s). `; }
                 else if (shipmentSections.length > 0) { message += "Check data format or carrier type. "; }
                 else { message += "Check data format. "; }
                 input.placeholder = message;
            }
        } else {
            let finalOutputString = '';
            if (parsedDataBlocksForAmzl.length > 0) {
                if (groupSize > 1) {
                    const groupedOutputs = [];
                    for (let i = 0; i < parsedDataBlocksForAmzl.length; i += groupSize) {
                        const dataChunk = parsedDataBlocksForAmzl.slice(i, i + groupSize);
                        const completeTemplate = amzlTemplate + "\n\n" + dataChunk.join('\n\n');
                        groupedOutputs.push(completeTemplate);
                    }
                    finalOutputString = groupedOutputs.join('\n\n');
                } else {
                    const individualOutputs = parsedDataBlocksForAmzl.map(dataBlock => amzlTemplate + "\n\n" + dataBlock );
                    finalOutputString = individualOutputs.join('\n\n');
                }

                const currentNoteTrimmed = currentNoteValue.trimEnd();
                const spacing = currentNoteTrimmed ? '\n\n' : '';
                noteArea.value = currentNoteTrimmed + spacing + finalOutputString;
                noteArea.scrollTop = noteArea.scrollHeight;

                countTemplatesNoteTaker(); // This will also save notes due to its internal listener
                // saveNotesToLocalStorage(); // No longer strictly needed here if countTemplatesNoteTaker saves

                input.value = '';
                const groupingStatus = groupSize > 1 ? `ON (${groupSize} per template)` : 'OFF';
                let processedMessage = `Processed ${validShipmentsFound} new AMZL shipment(s). `;
                 if (skippedDuplicateCount > 0) { processedMessage += `Skipped ${skippedDuplicateCount} duplicate(s). `; }
                processedMessage += `Grouping: ${groupingStatus}. Ready...`;
                 input.placeholder = processedMessage;
            } else {
                input.value = '';
                 let message = "No new valid AMZL shipments found. ";
                 if (skippedDuplicateCount > 0) { message += `Skipped ${skippedDuplicateCount} duplicate(s). `; }
                 else if (shipmentSections.length > 0) { message += "Check data format or carrier type. "; }
                 else { message += "Check data format. "; }
                 input.placeholder = message;
            }
        }

        setTimeout(() => {
            if (input) {
                const currentModeIsUps = document.getElementById('upsUspsToggle')?.checked;
                input.placeholder = currentModeIsUps
                    ? "Paste shipment data containing UPS/USPS..."
                    : "Paste Amazon removal shipment data here...";
            }
        }, 5000);
    }

   function processUpsUspsData() {
        const upsUspsOutputArea = document.getElementById('upsUspsOutputArea');
        const noteArea = document.getElementById('noteArea');
        const shipmentInput = document.getElementById('shipmentInput');

        if (!upsUspsOutputArea || !noteArea || !shipmentInput) {
            console.error("Cannot process UPS/USPS data: Missing required elements.");
            return;
        }

        const trackingNumbersToProcess = upsUspsOutputArea.value.split('\n').map(tn => tn.trim()).filter(tn => tn);

        if (trackingNumbersToProcess.length === 0) {
            alert("No UPS/USPS tracking numbers found in the staging area.");
            return;
        }

        let processedBlocks = [];
        let notFoundCount = 0;
        const processedTNs = new Set();

        trackingNumbersToProcess.forEach(tn => {
            const coreTN = tn.replace(/\s|-/g, '');
            if (!processedTNs.has(coreTN)) {
                if (tempUpsUspsData[coreTN]) {
                    const formattedBlock = upsUspsTemplate + "\n\n" + tempUpsUspsData[coreTN];
                    processedBlocks.push(formattedBlock);
                    processedTNs.add(coreTN);
                } else {
                    console.warn(`Could not find data block for staged TN: ${tn}`);
                    notFoundCount++;
                }
            }
        });

        if (processedBlocks.length > 0) {
            const currentNoteTrimmed = noteArea.value.trimEnd();
            const spacing = currentNoteTrimmed ? '\n\n' : '';
            noteArea.value = currentNoteTrimmed + spacing + processedBlocks.join('\n\n');
            noteArea.scrollTop = noteArea.scrollHeight;

            countTemplatesNoteTaker(); // This will also save notes
            // saveNotesToLocalStorage(); // No longer strictly needed here

            upsUspsOutputArea.value = '';
            tempUpsUspsData = {};

            saveUpsUspsOutputToLocalStorage();
            saveUpsUspsContextToLocalStorage();

            shipmentInput.placeholder = `Added ${processedBlocks.length} UPS/USPS entries to notes. Ready...`;
            setTimeout(() => {
                if (shipmentInput) {
                     shipmentInput.placeholder = "Paste shipment data containing UPS/USPS...";
                }
             }, 3000);

        } else {
            alert("No data could be processed. Check console for details.");
        }
        if (notFoundCount > 0) {
             alert(`Warning: Could not find original data for ${notFoundCount} tracking number(s) listed.`);
        }
   }


    function addSeparator() { const ta = document.getElementById('noteArea'); const trimmedValue = ta.value.trimEnd(); ta.value = trimmedValue + (trimmedValue ? noteSeparator : ''); ta.focus(); ta.scrollTop = ta.scrollHeight; countTemplatesNoteTaker(); /* saveNotesToLocalStorage(); // covered by countTemplates */ }
    function addSpacing() { const ta = document.getElementById('noteArea'); ta.value = ta.value.trimEnd() + '\n\n'; ta.focus(); ta.scrollTop = ta.scrollHeight; saveNotesToLocalStorage(); /* Only save here, no need to recount for just spacing */ }
    function selectAllMerchants() { document.querySelectorAll('#merchantList .merchant-checkbox').forEach(cb => { cb.checked = true; }); updateSelectedCountNoteTaker(); }


    function handleMerchantNameEdit(event, originalSectionKey, originalDisplayName, isNameOriginallyFromFirstLine) {
        const editableSpan = event.target;
        const newName = editableSpan.textContent.trim();

        if (!newName || newName === originalDisplayName) {
            editableSpan.textContent = originalDisplayName;
            return;
        }

        const noteArea = document.getElementById('noteArea');
        const currentNotes = noteArea.value;
        let newSectionText;

        if (isNameOriginallyFromFirstLine) {
            const lines = originalSectionKey.split('\n');
            newSectionText = newName + (lines.length > 1 ? '\n' + lines.slice(1).join('\n') : '');
        } else {
            newSectionText = newName + '\n\n' + originalSectionKey;
        }

        const noteSeparatorCaptureRegex = new RegExp('(' + noteSeparator.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'g');
        const parts = currentNotes.split(noteSeparatorCaptureRegex);
        let reconstructedNotes = "";
        let replaced = false;

        for (let i = 0; i < parts.length; i++) {
            if (i % 2 === 0) { // Content part
                if (parts[i].trim() === originalSectionKey.trim()) {
                    reconstructedNotes += newSectionText;
                    replaced = true;
                } else {
                    reconstructedNotes += parts[i];
                }
            } else { // Separator part
                reconstructedNotes += parts[i];
            }
        }

        if (replaced) {
            noteArea.value = reconstructedNotes;
            // Call countTemplatesNoteTaker AFTER saving, as it reads from noteArea for its processing.
            saveNotesToLocalStorage();
            countTemplatesNoteTaker(); // This will re-render the list with the new name.
        } else {
            console.warn("Failed to replace section text for name edit. Original section key:", originalSectionKey);
            editableSpan.textContent = originalDisplayName; // Revert UI
        }
    }

    function countTemplatesNoteTaker() {
        const noteArea = document.getElementById('noteArea');
        const fullText = noteArea.value;
        const merchantListDiv = document.getElementById('merchantList');
        merchantListDiv.innerHTML = ''; // Clear previous items

        const trackingNumberRegex = /\b([A-Z0-9]+(?:-|\s)*\((?:AMZ[NL]|UPS|USPS)\))/gi;
        const allTrackingNumbers = (fullText.match(trackingNumberRegex) || []);
        const seenTrackingNumbers = new Set();
        const duplicatedTrackingNumbers = new Set();
        allTrackingNumbers.forEach(tn => {
            const coreTN = tn.replace(/\s*\((?:AMZ[NL]|UPS|USPS)\)$/i, '').replace(/\s|-/g, '');
            if (seenTrackingNumbers.has(coreTN)) { duplicatedTrackingNumbers.add(coreTN); }
            seenTrackingNumbers.add(coreTN);
        });

        const merchantsData = {}; // Use this to hold structured data before sorting
        let totalTemplatesOverall = 0;
        let merchantIndex = 0;
        const sections = fullText.split(noteSeparatorRegex);

        sections.forEach((sectionTextOriginal) => {
            const sectionText = sectionTextOriginal.trim();
            if (!sectionText) return;

            const amzlTemplateCount = countTemplatesInText(sectionText, amzlTemplate);
            const upsUspsTemplateCount = countTemplatesInText(sectionText, upsUspsTemplate);
            const templateCount = amzlTemplateCount + upsUspsTemplateCount;
            totalTemplatesOverall += templateCount;

            let merchantName = `Entry ${++merchantIndex}`;
            const firstLine = sectionText.split('\n')[0]?.trim();
            let isNameFromFirstLine = false;

            if (firstLine && !firstLine.startsWith(amzlTemplate.substring(0, 10)) && !firstLine.startsWith(upsUspsTemplate.substring(0,10)) && firstLine.length < 100 && !firstLine.includes(':') && !firstLine.startsWith('Removal order ID')) {
                merchantName = firstLine;
                isNameFromFirstLine = true;
            } else if (sectionText.includes('Removal order ID:')) {
                 merchantName = `Data Entry ${merchantIndex}`;
            }

            merchantsData[sectionTextOriginal] = { // Use original section text as key to preserve whitespace for replacement
                 displayName: merchantName,
                 isNameFromFirstLine: isNameFromFirstLine,
                 count: templateCount,
                 text: sectionTextOriginal // Store the original, possibly non-trimmed version
            };
        });

        document.getElementById('merchantCount').textContent = Object.keys(merchantsData).length;
        document.getElementById('totalTemplates').textContent = totalTemplatesOverall;

        // Sort by displayName for rendering
        const sortedMerchants = Object.entries(merchantsData).sort(([, a], [, b]) => a.displayName.localeCompare(b.displayName));

        sortedMerchants.forEach(([key, data]) => {
            const merchantDiv = document.createElement('div');
            merchantDiv.className = 'merchant-stats';
            merchantDiv.dataset.key = key; // This key is the original section text
            merchantDiv.dataset.displayName = data.displayName;
            merchantDiv.dataset.count = data.count;

            const sectionTrackingNumbersFull = (data.text.match(trackingNumberRegex) || []);
            let sectionHasDuplicate = false;
            const duplicatesInSectionDisplay = new Set();
            sectionTrackingNumbersFull.forEach(tn => {
                const coreTn = tn.replace(/\s*\((?:AMZ[NL]|UPS|USPS)\)$/i, '').replace(/\s|-/g, '');
                if (duplicatedTrackingNumbers.has(coreTn)) {
                    sectionHasDuplicate = true;
                    duplicatesInSectionDisplay.add(tn);
                }
            });

            const titleText = `${data.displayName} (${data.count} ${data.count === 1 ? 'case' : 'cases'})`;

            const innerFlexDiv = document.createElement('div');
            // innerFlexDiv's style is set by .merchant-stats > div in CSS

            if (sectionHasDuplicate) {
                const indicatorSpan = document.createElement('span');
                indicatorSpan.className = 'duplicate-indicator';
                const dupeListString = Array.from(duplicatesInSectionDisplay).join(', ');
                indicatorSpan.title = `Contains duplicate TN(s): ${dupeListString}`;
                innerFlexDiv.appendChild(indicatorSpan);
            }

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'merchant-checkbox';
            checkbox.onchange = updateSelectedCountNoteTaker;
            innerFlexDiv.appendChild(checkbox);

            const nameAndCountWrapper = document.createElement('span');
            nameAndCountWrapper.className = 'merchant-name-editable-container';
            // Style from CSS

            const nameSpan = document.createElement('span');
            nameSpan.className = 'merchant-name-display';
            nameSpan.contentEditable = true;
            nameSpan.textContent = data.displayName;
            nameSpan.title = titleText + (sectionHasDuplicate ? ` | DUPLICATES FOUND: ${Array.from(duplicatesInSectionDisplay).join(', ')}` : '');
            // Style from CSS

            nameSpan.addEventListener('blur', (e) => handleMerchantNameEdit(e, key, data.displayName, data.isNameFromFirstLine));
            nameSpan.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.preventDefault(); e.target.blur(); }
                else if (e.key === 'Escape') { e.preventDefault(); e.target.textContent = data.displayName; e.target.blur(); }
            });
            nameAndCountWrapper.appendChild(nameSpan);

            const countSpan = document.createElement('span');
            countSpan.className = 'merchant-count-text';
            countSpan.textContent = `(${data.count} ${data.count === 1 ? 'case' : 'cases'})`;
            // Style from CSS
            nameAndCountWrapper.appendChild(countSpan);
            innerFlexDiv.appendChild(nameAndCountWrapper);

            if (sectionHasDuplicate) {
                const duplicateListSpan = document.createElement('span');
                const duplicateList = Array.from(duplicatesInSectionDisplay).join(', ');
                duplicateListSpan.style.cssText = "color: #ff9f0a; font-size: 0.8em; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-shrink: 1; max-width: 80px;"; // Adjusted max-width
                duplicateListSpan.title = `Duplicate TN(s): ${duplicateList}`;
                duplicateListSpan.textContent = `(${duplicateList})`;
                innerFlexDiv.appendChild(duplicateListSpan);
            }

            merchantDiv.appendChild(innerFlexDiv);
            merchantDiv.onclick = (e) => {
                 if (e.target.type !== 'checkbox' && e.target.contentEditable !== true) { // Don't toggle if clicking name
                     const cb = merchantDiv.querySelector('.merchant-checkbox');
                     if (cb) { cb.checked = !cb.checked; updateSelectedCountNoteTaker(); }
                 }
             };
            merchantListDiv.appendChild(merchantDiv);
        });
        updateSelectedCountNoteTaker();
    }


    function updateSelectedCountNoteTaker() {
        const selectedCheckboxes = document.querySelectorAll('#merchantList .merchant-checkbox:checked');
        const splitButton = document.getElementById('btnSplitSelected');
        let selectedCaseCount = 0;

        selectedCheckboxes.forEach(cb => {
            selectedCaseCount += parseInt(cb.closest('.merchant-stats')?.dataset?.count || '0', 10);
        });

        const totalTemplatesSpan = document.getElementById('totalTemplates');
        const merchantCountSpan = document.getElementById('merchantCount');
        const totalMerchantCount = document.querySelectorAll('#merchantList .merchant-stats').length;
        const totalCaseCountOverall = Array.from(document.querySelectorAll('#merchantList .merchant-stats')).reduce((sum, el) => sum + parseInt(el.dataset.count || '0', 10), 0);

        if (selectedCheckboxes.length > 0) {
            totalTemplatesSpan.textContent = selectedCaseCount;
            merchantCountSpan.textContent = selectedCheckboxes.length;
            if (splitButton) { splitButton.disabled = false; }
        } else {
            totalTemplatesSpan.textContent = totalCaseCountOverall;
            merchantCountSpan.textContent = totalMerchantCount;
            if (splitButton) { splitButton.disabled = true; }
        }
    }


    function downloadSelectedMerchants() {
        const selectedDivs = document.querySelectorAll('#merchantList .merchant-stats:has(.merchant-checkbox:checked)');
        if (selectedDivs.length === 0) { alert('Please select merchant(s) to download.'); return; }

        const textsToDownload = [];
        let totalSelectedCases = 0;
        selectedDivs.forEach((div) => {
            const key = div.dataset.key; // This key is the full original section text
            if (key !== undefined && key !== null) {
                textsToDownload.push(key);
                totalSelectedCases += parseInt(div.dataset.count || '0', 10);
            }
        });

        if (textsToDownload.length === 0) { alert("Could not retrieve text for selected merchants."); return; }

        const combinedText = textsToDownload.join(noteSeparator.trimEnd()); // Use trimEnd on separator for joining
        const filename = `3COUTB_${getFormattedDate()}_(${totalSelectedCases}).txt`;
        downloadText(combinedText + '\n', filename); // Add trailing newline to file
    }

    function clearSelectedMerchants() {
        const selectedDivs = document.querySelectorAll('#merchantList .merchant-stats:has(.merchant-checkbox:checked)');
        if (selectedDivs.length === 0) { alert('Please select merchant(s) to clear.'); return; }

        const noteArea = document.getElementById('noteArea');
        const fullText = noteArea.value;
        const keysToRemove = new Set();
        selectedDivs.forEach(div => { if (div.dataset.key !== undefined && div.dataset.key !== null) { keysToRemove.add(div.dataset.key); } });

        // Refined clearing logic: Filter sections and join.
        const allSections = [];
        // let currentSection = ""; // This variable was unused
        fullText.split(noteSeparatorRegex).forEach(s => {
            // s is the content *between* separators.
            // If noteArea starts/ends with a separator, or has consecutive separators,
            // split can produce empty strings. We filter these out.
            if (s.trim() !== "") {
                allSections.push(s); // Push the original section text (can have leading/trailing spaces if they were part of the section)
            }
        });

        const remainingSections = allSections.filter(section => !keysToRemove.has(section));

        if (remainingSections.length > 0) {
             // Corrected line: Join remaining sections with the single, original noteSeparator
             noteArea.value = remainingSections.join(noteSeparator);
        } else {
            noteArea.value = ""; // Clear entirely if no sections remain
        }

        countTemplatesNoteTaker(); // This will re-render the list and save the notes
    }

    function downloadAllNotes() {
        const noteArea = document.getElementById('noteArea');
        const textToDownload = noteArea.value.trim();
        if (!textToDownload) { alert("Nothing to download."); return; }
        const totalTemplatesCount = document.getElementById('totalTemplates').textContent;
        const filename = `3COUTB_${getFormattedDate()}_(${totalTemplatesCount}).txt`;
        downloadText(textToDownload + '\n', filename);
    }


    function processSingleROBlock(roBlockText, removalOrdersArray) {
        const roIdLineMatch = roBlockText.match(/^\s*Removal order ID:[^\n]+/);
        if (!roIdLineMatch) {
            return;
        }
        const currentRoIdLine = roIdLineMatch[0].trim();

        const remainingText = roBlockText.substring(roIdLineMatch[0].length).trim();
        if (!remainingText) { return; }

        const shipmentBlocks = remainingText.split(/(?=^\s*Shipment ID:)/m);

        shipmentBlocks.forEach((shipmentBlock) => {
             const trimmedShipmentBlock = shipmentBlock.trim();
             if (trimmedShipmentBlock.startsWith('Shipment ID:') && trimmedShipmentBlock.includes('Merchant SKU:')) {
                 const completeOrderBlock = (currentRoIdLine + '\n' + trimmedShipmentBlock);
                 removalOrdersArray.push(completeOrderBlock);
             }
        });
    }

   function splitTextIntoRemovalOrders(inputText) {
        const removalOrders = [];
        if (!inputText) { return removalOrders; }

        let textToProcess = inputText.trim();
        const escapedAmzlTemplate = amzlTemplate.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const escapedUpsUspsTemplate = upsUspsTemplate.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const templateRegexAmzl = new RegExp('^\\s*' + escapedAmzlTemplate + '\\s*\\n*', 'gm');
        const templateRegexUpsUsps = new RegExp('^\\s*' + escapedUpsUspsTemplate + '\\s*\\n*', 'gm');

        textToProcess = textToProcess.replace(templateRegexAmzl, '').replace(templateRegexUpsUsps, '').trim();

        // Remove potential merchant name headers before splitting by RO ID
        const linesForRO = textToProcess.split('\n');
        if (linesForRO.length > 2 && linesForRO[1].trim() === "" && linesForRO[2].startsWith("Removal order ID:")) {
            // Likely 'Merchant Name\n\nRemoval order ID:...'
            textToProcess = linesForRO.slice(2).join('\n');
        } else if (linesForRO.length > 0 && linesForRO[0].startsWith("Removal order ID:")) {
            // Already starts with RO ID
            textToProcess = linesForRO.join('\n');
        }
        // If it was just a merchant name, it will be filtered out by processSingleROBlock anyway.


        const potentialROBlocks = textToProcess.split(/(?=^\s*Removal order ID:)/m);

        potentialROBlocks.forEach((roBlock) => {
            const trimmedROBlock = roBlock.trim();
            if (!trimmedROBlock) return;
            if (trimmedROBlock.startsWith('Removal order ID:')) {
                processSingleROBlock(trimmedROBlock, removalOrders);
            }
        });
        return removalOrders;
   }

   function createTemplates(removalOrders, removalOrdersPerTemplate) {
        const templates = [];
        if (!removalOrders || removalOrders.length === 0 || removalOrdersPerTemplate <= 0) {
            return templates;
        }
        for (let i = 0; i < removalOrders.length; i += removalOrdersPerTemplate) {
            const templateRemovalOrders = removalOrders.slice(i, i + removalOrdersPerTemplate);
             const validOrders = templateRemovalOrders.filter(order => order && typeof order === 'string');
             if (validOrders.length > 0) {
                 templates.push(validOrders.join('\n\n'));
             }
        }
        return templates;
   }

    let selectedMerchantDataForSplit = [];

    function openSplitModal() {
        selectedMerchantDataForSplit = [];
        const selectedDivs = document.querySelectorAll('#merchantList .merchant-stats:has(.merchant-checkbox:checked)');
        if (selectedDivs.length === 0) { alert("Please select at least one merchant to split."); return; }

        const modalElements = {
            modal: document.getElementById('splitModal'),
            merchantInfoDiv: document.getElementById('splitMerchantInfo'),
            ordersPerTemplateInput: document.getElementById('splitOrdersPerTemplate'),
            calculatedTemplatesSpan: document.getElementById('splitCalculatedTemplates'),
            splitNumberInput: document.getElementById('splitNumberInput')
        };
        let missingElement = null;
        for (const key in modalElements) { if (!modalElements[key]) { missingElement = key; break; } }
        if (missingElement) { console.error(`openSplitModal error: Modal element with ID '${missingElement}' not found!`); alert("Error: Could not initialize the split dialog."); return; }

        const modal = modalElements.modal;
        const merchantInfoDiv = modalElements.merchantInfoDiv;
        const ordersPerTemplateInput = modalElements.ordersPerTemplateInput;
        const calculatedTemplatesSpan = modalElements.calculatedTemplatesSpan;
        const splitNumberInput = modalElements.splitNumberInput;

        let combinedTextParts = [];
       let containsUpsUsps = false;
       let containsAmzl = false;

        selectedDivs.forEach((div) => {
            const key = div.dataset.key; // Full original section text
            const displayName = div.dataset.displayName || `Merchant (Unknown)`;
            if (key !== undefined && key !== null) {
                selectedMerchantDataForSplit.push({ key: key, name: displayName });
                combinedTextParts.push(key);
                if (key.includes(upsUspsTemplate)) containsUpsUsps = true;
                if (key.includes(amzlTemplate)) containsAmzl = true;
            }
        });
        const merchantNames = selectedMerchantDataForSplit.map(item => item.name);
        const combinedText = combinedTextParts.join(noteSeparator.trimEnd()); // Use trimEnd on separator for joining
        modal.dataset.combinedText = combinedText;
        modal.dataset.containsAmzl = containsAmzl;
        modal.dataset.containsUpsUsps = containsUpsUsps;


        if (merchantNames.length === 1) { merchantInfoDiv.textContent = `Merchant: ${merchantNames[0]}`; }
        else if (merchantNames.length > 1) { merchantInfoDiv.textContent = `Merchants: ${merchantNames.slice(0, 3).join(', ')}${merchantNames.length > 3 ? '...' : ''} (${merchantNames.length} total)`; }
        else { merchantInfoDiv.textContent = 'No valid merchants selected.'; }

        ordersPerTemplateInput.value = '2';
        splitNumberInput.value = ''; // Default to empty, user must fill
        calculatedTemplatesSpan.textContent = '0';
        updateCalculatedTemplates();
        modal.style.display = 'flex';
    }

    function closeSplitModal() {
        const modal = document.getElementById('splitModal');
        if(modal) {
          modal.style.display = 'none';
          modal.dataset.combinedText = '';
          modal.dataset.containsAmzl = '';
          modal.dataset.containsUpsUsps = '';
        }
    }

    function updateCalculatedTemplates() {
         const modal = document.getElementById('splitModal');
         if (!modal) return;
         const combinedText = modal.dataset.combinedText || '';
         const ordersPerTemplateInput = document.getElementById('splitOrdersPerTemplate');
         const calculatedTemplatesSpan = document.getElementById('splitCalculatedTemplates');
         if (!ordersPerTemplateInput || !calculatedTemplatesSpan) return;

         const ordersPerTemplate = parseInt(ordersPerTemplateInput.value) || 0;
         if (ordersPerTemplate > 0 && combinedText) {
             const removalOrders = splitTextIntoRemovalOrders(combinedText);
             const templateGroups = createTemplates(removalOrders, ordersPerTemplate);
             calculatedTemplatesSpan.textContent = templateGroups.length;
         } else {
             calculatedTemplatesSpan.textContent = '0';
         }
       }

   function generateAndDownloadSplits() {
        const modal = document.getElementById('splitModal');
        if (!modal) return;

        const combinedText = modal.dataset.combinedText || '';
        const ordersPerTemplateInput = document.getElementById('splitOrdersPerTemplate');
        const splitNumberInput = document.getElementById('splitNumberInput');
        const containsAmzl = modal.dataset.containsAmzl === 'true';
        const containsUpsUsps = modal.dataset.containsUpsUsps === 'true';

        if (!ordersPerTemplateInput || !splitNumberInput) { alert("Error: Modal inputs not found."); return; }

        const ordersPerTemplate = parseInt(ordersPerTemplateInput.value);
        const splitNumber = parseInt(splitNumberInput.value);

        if (!combinedText) { alert("Error: No text found for selected merchants."); return; }
        if (isNaN(ordersPerTemplate) || ordersPerTemplate < 1) { alert("Please enter a valid number for 'Removal Orders per Template'."); return; }
        if (isNaN(splitNumber) || splitNumber < 1) { alert("Please enter a valid number for 'Templates per Split File'."); return; }

        let templateToUse = amzlTemplate;
        if (containsUpsUsps && !containsAmzl) {
            templateToUse = upsUspsTemplate;
        } else if (containsUpsUsps && containsAmzl) {
            // For mixed content, it's safer to stick to one, or this needs more complex logic.
            // Assuming AMZL template is general enough or user is aware.
            console.warn("Split contains mixed AMZL and UPS/USPS entries. Using AMZL template for splitting. This might not be ideal for UPS/USPS only data.");
        }

        const removalOrders = splitTextIntoRemovalOrders(combinedText);
        if (removalOrders.length === 0) {
            alert("Could not find any valid removal orders in the selected text after cleaning. Please check data format or if selected entries were only merchant names.");
            return;
        }

        const templateGroups = createTemplates(removalOrders, ordersPerTemplate);
        if (templateGroups.length === 0) { alert("Failed to generate template groups. This might happen if 'Orders per Template' is too high or data is unusual."); return; }

        const splitOutputs = [];
        for (let i = 0; i < templateGroups.length; i += splitNumber) {
            const groupChunk = templateGroups.slice(i, i + splitNumber);
            if (groupChunk.length > 0) {
                 let chunkText = '';
                 groupChunk.forEach((group, index) => {
                     // Determine which template to use based on content of *this specific group* if possible
                     // For now, stick to the globally decided `templateToUse`
                     chunkText += templateToUse + '\n\n' + group;
                     if (index < groupChunk.length - 1) {
                         chunkText += '\n\n'; // Separator between templates in the same file (if any)
                                            // Typically, this is not a separator between templates, but between the template text and the data.
                                            // The current structure is Template + Data1 + Data2 ...
                                            // So, it should be: (Template + DataGroup1) \n\n (Template + DataGroup2) ... if splitNumber > 1
                                            // No, templateGroups are already structured with N orders.
                                            // Each item in groupChunk is already a block of text representing one filled template.
                                            // So, join them with \n\n if a file has multiple templates.
                     }
                 });
                 // Corrected logic: each templateGroup item is data for ONE template.
                 // If splitNumber > 1, we group multiple (template+data) blocks.
                 const fileTemplates = groupChunk.map(dataForOneTemplate => templateToUse + "\n\n" + dataForOneTemplate);
                splitOutputs.push({ text: fileTemplates.join('\n\n'), count: groupChunk.length });
            }
        }

        if (splitOutputs.length === 0) { alert("No split files generated."); return; }

        let filenameMerchantPart = "SplitSelection";
        let merchantDisplayStringForFile = selectedMerchantDataForSplit.map(m=>m.name).join(' & '); // Use name from data passed to modal

        if (selectedMerchantDataForSplit.length === 1) {
            filenameMerchantPart = sanitizeFilename(selectedMerchantDataForSplit[0].name);
        } else if (selectedMerchantDataForSplit.length > 1) {
            filenameMerchantPart = sanitizeFilename(selectedMerchantDataForSplit[0].name) + "_Multi";
        }


        const dateStr = getFormattedDate();
        splitOutputs.forEach((outputData, index) => {
            const partNumber = index + 1;
            const filename = `3COUTB_${dateStr}_${filenameMerchantPart}_PART_${partNumber}(${outputData.count}).txt`;
            // Prepend the actual merchant name(s) to the file content
            const fileContent = merchantDisplayStringForFile + '\n\n' + outputData.text + '\n';
            downloadText(fileContent, filename);
        });

        closeSplitModal();
   }

    document.addEventListener('DOMContentLoaded', () => {
        const shipmentInput = document.getElementById('shipmentInput');
        const noteArea = document.getElementById('noteArea');
        const groupToggle = document.getElementById('groupToggle');
        const groupSizeInput = document.getElementById('parserGroupSize');
        const upsUspsToggle = document.getElementById('upsUspsToggle');
        const upsUspsOutputContainer = document.getElementById('upsUspsOutputContainer');
        const upsUspsOutputArea = document.getElementById('upsUspsOutputArea');
        const groupOrdersControl = document.getElementById('groupOrdersControl');
        // const btnProcessUpsUsps = document.getElementById('btnProcessUpsUsps'); // Handled by container listener


        if (noteArea) {
            const savedNotes = localStorage.getItem(localStorageKey);
            if (savedNotes) { noteArea.value = savedNotes; }
             let countTimer;
             noteArea.addEventListener('input', () => {
                 clearTimeout(countTimer);
                 countTimer = setTimeout(() => {
                     saveNotesToLocalStorage(); // Save first
                     countTemplatesNoteTaker(); // Then recount/re-render
                    }, 300);
             });
             noteArea.addEventListener('paste', (e) => {
                 setTimeout(() => {
                     saveNotesToLocalStorage(); // Save first
                     countTemplatesNoteTaker(); // Then recount/re-render
                    }, 50);
             });
        } else { console.error("Note area element not found!"); }

        if (upsUspsOutputArea) {
            const savedUpsUspsTNs = localStorage.getItem(upsUspsOutputKey);
            if (savedUpsUspsTNs) {
                upsUspsOutputArea.value = savedUpsUspsTNs;
            }
        } else { console.error("UPS/USPS output area element not found!"); }

        try {
            const savedUpsUspsContext = localStorage.getItem(upsUspsContextKey);
            if (savedUpsUspsContext) {
                tempUpsUspsData = JSON.parse(savedUpsUspsContext);
                if (typeof tempUpsUspsData !== 'object' || tempUpsUspsData === null) {
                    tempUpsUspsData = {};
                }
            } else {
                tempUpsUspsData = {};
            }
        } catch (error) {
            console.error("Error loading UPS/USPS context from localStorage:", error);
            tempUpsUspsData = {};
        }


        if (shipmentInput) {
            let parseTimer;
            shipmentInput.addEventListener('input', () => {
                clearTimeout(parseTimer);
                if (shipmentInput.value.trim()) { parseTimer = setTimeout(parseShipmentData, 500); }
            });
        } else { console.error("Shipment input element not found!"); }

        try { countTemplatesNoteTaker(); } catch(error) { console.error("Error during initial countTemplatesNoteTaker:", error); }

         // Consolidated event listener for buttons in both merchant-actions-tool and note-taker-tool
         document.querySelector('.main-wrapper').addEventListener('click', function(event) {
            const targetButton = event.target.closest('button');
            if (!targetButton || targetButton.closest('#splitModal')) { return; } // Ignore modal buttons

            try {
                switch (targetButton.id) {
                    // Note Taker Tool Buttons
                    case 'btnAddSeparator': addSeparator(); break;
                    case 'btnAddSpacing': addSpacing(); break;
                    // case 'btnUndo': // Placeholder, no function yet
                    // case 'btnRedo': // Placeholder, no function yet

                    // Merchant Actions Tool Buttons
                    case 'btnDownloadSelected': downloadSelectedMerchants(); break;
                    case 'btnClearSelected': clearSelectedMerchants(); break;
                    case 'btnSelectAll': selectAllMerchants(); break;
                    case 'btnDownloadAll': downloadAllNotes(); break;
                    case 'btnSplitSelected': openSplitModal(); break;

                    // Parser Tool Button (specifically for btnProcessUpsUsps)
                    case 'btnProcessUpsUsps':
                        if (targetButton.closest('.parser-tool')) { // Ensure it's the one in parser tool
                            processUpsUspsData();
                        }
                        break;
                    default: break;
                }
            } catch (error) {
                console.error(`Error executing action for button ${targetButton.id}:`, error);
            }
        });


         if (groupToggle && groupSizeInput) {
               groupToggle.addEventListener('change', function() { groupSizeInput.disabled = !this.checked; });
               groupSizeInput.disabled = !groupToggle.checked;
         } else { console.error("Parser Group toggle or group size input not found!"); }

         if (upsUspsToggle && upsUspsOutputContainer && groupOrdersControl && shipmentInput && upsUspsOutputArea) {
             function toggleUpsUspsMode(isUpsMode) {
                  upsUspsOutputContainer.style.display = isUpsMode ? 'block' : 'none';
                  groupOrdersControl.style.opacity = isUpsMode ? '0.5' : '1';
                  groupOrdersControl.style.pointerEvents = isUpsMode ? 'none' : 'auto';
                  if (isUpsMode && groupToggle) {
                      groupToggle.checked = false;
                       if (groupSizeInput) groupSizeInput.disabled = true;
                  }

                  if (isUpsMode) {
                      shipmentInput.placeholder = "Paste shipment data containing UPS/USPS...";
                  } else {
                      upsUspsOutputArea.value = '';
                      tempUpsUspsData = {};
                      saveUpsUspsOutputToLocalStorage();
                      saveUpsUspsContextToLocalStorage();
                      shipmentInput.placeholder = "Paste Amazon removal shipment data here...";
                      if (groupToggle && groupSizeInput) groupSizeInput.disabled = !groupToggle.checked;
                  }
             }

              upsUspsToggle.addEventListener('change', function() {
                  toggleUpsUspsMode(this.checked);
              });
              toggleUpsUspsMode(upsUspsToggle.checked);

         } else { console.error("Parser UPS/USPS toggle or related elements not found!"); }

         const splitModalEl = document.getElementById('splitModal');
         const btnCancelSplit = document.getElementById('btnCancelSplit');
         const btnGenerateSplits = document.getElementById('btnGenerateSplits');
         const ordersPerTemplateInputModal = document.getElementById('splitOrdersPerTemplate');
         if (splitModalEl && btnCancelSplit && btnGenerateSplits && ordersPerTemplateInputModal) {
               btnCancelSplit.addEventListener('click', closeSplitModal);
               splitModalEl.addEventListener('click', (event) => {
                    if (event.target === splitModalEl) { closeSplitModal(); }
                 });
               btnGenerateSplits.addEventListener('click', generateAndDownloadSplits);
               ordersPerTemplateInputModal.addEventListener('input', updateCalculatedTemplates);
         } else { console.error("Could not attach one or more Split Modal event listeners."); }
    });
</script>

</body>
</html>
